/**
 * Generate an SVG cutting template for Silhouette Cameo based on current print settings.
 * The SVG can be imported into Silhouette Studio and saved as a .studio3 file.
 */

import { baseCardWidthMm, baseCardHeightMm } from './layout';

// MTG card corner radius
const CARD_CORNER_RADIUS_MM = 2.5;

export interface CuttingTemplateSettings {
    pageWidthMm: number;
    pageHeightMm: number;
    columns: number;
    rows: number;
    bleedMm: number;
    spacingMm: number;
    positionOffsetXMm: number;
    positionOffsetYMm: number;
    portrait: boolean;
}

/**
 * Convert current app settings to cutting template settings
 */
export function settingsToCuttingTemplate(
    pageWidth: number,
    pageHeight: number,
    pageSizeUnit: 'mm' | 'in',
    columns: number,
    rows: number,
    bleedEdge: boolean,
    bleedEdgeWidth: number,
    bleedEdgeUnit: 'mm' | 'in',
    cardSpacingMm: number,
    cardPositionX: number,
    cardPositionY: number,
    portrait: boolean
): CuttingTemplateSettings {
    // Convert page dimensions to mm
    const pageWidthMm = pageSizeUnit === 'in' ? pageWidth * 25.4 : pageWidth;
    const pageHeightMm = pageSizeUnit === 'in' ? pageHeight * 25.4 : pageHeight;

    // Convert bleed to mm
    const bleedMm = bleedEdge
        ? (bleedEdgeUnit === 'in' ? bleedEdgeWidth * 25.4 : bleedEdgeWidth)
        : 0;

    return {
        pageWidthMm,
        pageHeightMm,
        columns,
        rows,
        bleedMm,
        spacingMm: cardSpacingMm,
        positionOffsetXMm: cardPositionX,
        positionOffsetYMm: cardPositionY,
        portrait,
    };
}

/**
 * Calculate card cut positions based on settings
 */
function calculateCardPositions(settings: CuttingTemplateSettings): Array<{ x: number; y: number }> {
    const { pageWidthMm, pageHeightMm, columns, rows, bleedMm, spacingMm, positionOffsetXMm, positionOffsetYMm } = settings;

    // Card slot size (content + bleed on each side)
    const slotWidthMm = baseCardWidthMm + 2 * bleedMm;
    const slotHeightMm = baseCardHeightMm + 2 * bleedMm;

    // Grid dimensions
    const gridWidthMm = columns * slotWidthMm + (columns - 1) * spacingMm;
    const gridHeightMm = rows * slotHeightMm + (rows - 1) * spacingMm;

    // Grid start position (centered on page, plus any offset)
    const startXMm = (pageWidthMm - gridWidthMm) / 2 + positionOffsetXMm;
    const startYMm = (pageHeightMm - gridHeightMm) / 2 + positionOffsetYMm;

    const positions: Array<{ x: number; y: number }> = [];

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < columns; col++) {
            // Slot position
            const slotX = startXMm + col * (slotWidthMm + spacingMm);
            const slotY = startYMm + row * (slotHeightMm + spacingMm);

            // Cut line position is at content edge (offset by bleed from slot edge)
            const cutX = slotX + bleedMm;
            const cutY = slotY + bleedMm;

            positions.push({ x: cutX, y: cutY });
        }
    }

    return positions;
}

/**
 * Generate SVG content for cutting template
 *
 * Uses the same coordinate system as the PDF export (page corner as origin).
 * Portrait mode rotates the entire template 90° clockwise to match paper loaded in portrait orientation.
 */
export function generateCuttingTemplateSVG(settings: CuttingTemplateSettings): string {
    const { pageWidthMm, pageHeightMm, columns, portrait } = settings;

    // Calculate card positions based on original (landscape) page dimensions
    const positions = calculateCardPositions(settings);

    // For portrait mode, swap SVG dimensions
    const svgWidth = portrait ? pageHeightMm : pageWidthMm;
    const svgHeight = portrait ? pageWidthMm : pageHeightMm;

    // Build SVG
    const lines: string[] = [];

    lines.push(`<?xml version="1.0" encoding="UTF-8"?>`);
    lines.push(`<svg xmlns="http://www.w3.org/2000/svg"`);
    lines.push(`     width="${svgWidth}mm"`);
    lines.push(`     height="${svgHeight}mm"`);
    lines.push(`     viewBox="0 0 ${svgWidth} ${svgHeight}">`);
    lines.push(``);
    lines.push(`  <!--`);
    lines.push(`    Cutting template for Silhouette Cameo`);
    lines.push(`    Generated by Proxies at Home`);
    lines.push(`    `);
    lines.push(`    Page: ${svgWidth.toFixed(1)}mm x ${svgHeight.toFixed(1)}mm${portrait ? ' (portrait)' : ''}`);
    lines.push(`    Cards: ${positions.length} standard MTG cards (${baseCardWidthMm}mm x ${baseCardHeightMm}mm) in ${columns}x${settings.rows} grid`);
    lines.push(`    Bleed: ${settings.bleedMm}mm`);
    lines.push(`    Spacing: ${settings.spacingMm}mm`);
    lines.push(`    Corner radius: ${CARD_CORNER_RADIUS_MM}mm`);
    lines.push(`  -->`);
    lines.push(``);
    lines.push(`  <style>`);
    lines.push(`    .cut-line {`);
    lines.push(`      fill: none;`);
    lines.push(`      stroke: #FF0000;`);
    lines.push(`      stroke-width: 0.1;`);
    lines.push(`    }`);
    lines.push(`  </style>`);
    lines.push(``);

    // Invisible corner anchors to establish page bounds without creating cut lines
    lines.push(`  <!-- Page boundary anchors (no stroke, establishes bounding box) -->`);
    lines.push(`  <circle cx="0" cy="0" r="0.01" fill="none" stroke="none"/>`);
    lines.push(`  <circle cx="${svgWidth}" cy="0" r="0.01" fill="none" stroke="none"/>`);
    lines.push(`  <circle cx="0" cy="${svgHeight}" r="0.01" fill="none" stroke="none"/>`);
    lines.push(`  <circle cx="${svgWidth}" cy="${svgHeight}" r="0.01" fill="none" stroke="none"/>`);
    lines.push(``);

    // Add rectangles for each card
    lines.push(`  <!-- Card cut lines -->`);
    positions.forEach((pos, idx) => {
        const row = Math.floor(idx / columns);
        if (idx % columns === 0) {
            lines.push(`  <!-- Row ${row + 1} -->`);
        }

        let x: number, y: number, w: number, h: number;
        if (portrait) {
            // 90° clockwise rotation: (x, y) -> (y, pageWidth - x - cardWidth)
            x = pos.y;
            y = pageWidthMm - pos.x - baseCardWidthMm;
            w = baseCardHeightMm;
            h = baseCardWidthMm;
        } else {
            x = pos.x;
            y = pos.y;
            w = baseCardWidthMm;
            h = baseCardHeightMm;
        }

        lines.push(`  <rect class="cut-line" x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w}" height="${h}" rx="${CARD_CORNER_RADIUS_MM}" ry="${CARD_CORNER_RADIUS_MM}"/>`);
    });

    lines.push(``);
    lines.push(`</svg>`);

    return lines.join('\n');
}

/**
 * Download the cutting template as an SVG file
 */
export function downloadCuttingTemplate(settings: CuttingTemplateSettings): void {
    const svg = generateCuttingTemplateSVG(settings);
    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);

    const { pageWidthMm, pageHeightMm, columns, rows, bleedMm, portrait } = settings;
    const pageName = getPageSizeName(pageWidthMm, pageHeightMm);
    const orientation = portrait ? 'portrait' : 'landscape';
    const filename = `cutting_template_${pageName}_${columns}x${rows}_${bleedMm}mm_bleed_${orientation}.svg`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    setTimeout(() => URL.revokeObjectURL(url), 1000);
}

/**
 * Get a human-readable page size name
 */
function getPageSizeName(widthMm: number, heightMm: number): string {
    // Check common sizes (with small tolerance for floating point)
    const tolerance = 1;

    const sizes: Array<{ name: string; w: number; h: number }> = [
        { name: 'letter', w: 215.9, h: 279.4 },
        { name: 'letter_landscape', w: 279.4, h: 215.9 },
        { name: 'a4', w: 210, h: 297 },
        { name: 'a4_landscape', w: 297, h: 210 },
        { name: 'tabloid', w: 279.4, h: 431.8 },
        { name: 'tabloid_landscape', w: 431.8, h: 279.4 },
        { name: 'a3', w: 297, h: 420 },
        { name: 'a3_landscape', w: 420, h: 297 },
        { name: 'legal', w: 215.9, h: 355.6 },
        { name: 'legal_landscape', w: 355.6, h: 215.9 },
    ];

    for (const size of sizes) {
        if (Math.abs(widthMm - size.w) < tolerance && Math.abs(heightMm - size.h) < tolerance) {
            return size.name;
        }
    }

    return `${Math.round(widthMm)}x${Math.round(heightMm)}mm`;
}